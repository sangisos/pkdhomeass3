\documentclass[12pt, a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[swedish]{babel}
\usepackage{fullpage}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage[parfill]{parskip}

\title{Time complexity analasys of card cryptology functions}
\author{Anna Normark, 940319-1308 and Alexander Andersson, 860616-1530}

\begin{document}
\maketitle



\section{preprocess}
Our preprocess is in itself constant as it only calls our auxillary function preprocess'.
\subsection{preprocess'}
Let n be the length of the list cl. The worst case is if every caracter in cl is a alpha character, and the length of cl modulus 5 is 1, as we then have to add 4 X:s.

This function spends most of it's time in the fifth case, where it removes the first character c of the char list cl, checks if it is a alpha character (constant time), if it's not, recurse with the char removed from cl, else make it uppercase (constant time), add it to chunk (constant time) and removes 1 from chunkSize (constant time), then recurses on the new data.

For every fifth (actually every chunkSize:th) character that is added to chunk, we enter the forth case in preprocess', where we reset the chunkSize, send a empty list as new chunk, revers the old chunk (linear to chunkSize, in this case five), and adds the reversed chunkSize to the list full (constant time).

When we reach the end of cl, we add X:s, but as it is such a small part of the total it is negligible.

At last the total list of chunks is reversed, liniar to the length of cl divided by chunkSize, in this case 5.

All in all, this gives us:

$$C(n) = C(n-1) + f(n)$$
$$f(n) = \Theta(1)$$
$$C(n) = \Theta(n)$$ for case five,


$$C(n) = C(n - chunkSize) + f(n)$$
$$f(n) = \Theta(chunkSize)$$
$$C(n) = \Theta(n)$$ for case four, and

$$C(n) = f(n)$$
$$f(n) = \Theta(n/5)$$
$$C(n) = \Theta(n/5) = \Theta(n)$$ for either of the first two cases.

And thus we get the whole function:
$$C(n) = 3 * \Theta(n) = \Theta(n)$$

\section{encrypt and decrypt}




\section{keystream}

\subsection{moveJoker}
MoveJoker is a linear function since all the operation is linear and the function is not run recursivley.

\subsection{moveJokerAOneCard and moveJokerBTwoCards}
Both moveJokerAOneCard and moveJokerBTwoCards is linear because it only uses konstant operators until the last step, where it uses moveJoker, wich also is a linear function and therefor moveJokerAOneCard and moveJokerBTwoCards is linear.

\subsection{tripleCut}
Let n be the length of the deck. In worst case senario both jokers are at the end of the deck, as we have to traverse the whole deck.

The function is linear since it will only be run recursivley one time each call, accordning to theorem one.

$$C(n) = C(n-1) + f(n)$$
$$f(n) = \Theta(1)$$
$$ C(n) = Theta(n)$$

\subsection{countCut}
CountCut is a linear function since all the operations are linear and it does not run recursivley.

\subsection{findOutputLetter}
FindOutputLetter is a linear function since all the operators it uses is konstant except for List.nth wich is linear, and therefor in worst case senario the head of the deck is a joker.

\subsection{keystream'}


\end{document}
